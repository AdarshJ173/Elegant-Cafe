/**
 * GSAP (GreenSock Animation Platform) - Minimal version for Cafe Showcase
 * This is a simplified version for demonstration purposes.
 * For production, use the official GSAP library from https://greensock.com/
 */

(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.gsap = {}));
}(this, function(exports) {
    'use strict';

    // Core GSAP object
    const gsap = {};

    // Timeline class
    class Timeline {
        constructor() {
            this.animations = [];
        }

        to(targets, vars) {
            this.animations.push({ targets, vars, type: 'to' });
            return this;
        }

        from(targets, vars) {
            this.animations.push({ targets, vars, type: 'from' });
            return this;
        }

        fromTo(targets, fromVars, toVars) {
            this.animations.push({ targets, fromVars, toVars, type: 'fromTo' });
            return this;
        }
    }

    // Main GSAP functions
    gsap.to = function(targets, vars) {
        if (!targets) return;

        // Convert targets to array
        const elements = typeof targets === 'string' ? 
            document.querySelectorAll(targets) : 
            Array.isArray(targets) ? targets : [targets];

        const duration = vars.duration || 1;
        const ease = vars.ease || 'power2.out';
        const delay = vars.delay || 0;
        const stagger = vars.stagger || 0;

        elements.forEach((element, index) => {
            if (!element) return;

            const actualDelay = delay + (stagger * index);
            
            setTimeout(() => {
                // Create animation
                const animation = createAnimation(element, vars, duration);
                animation.play();
            }, actualDelay * 1000);
        });

        return { 
            duration: duration,
            then: function(callback) {
                setTimeout(callback, (duration + delay + (stagger * elements.length)) * 1000);
            }
        };
    };

    gsap.from = function(targets, vars) {
        const fromVars = Object.assign({}, vars);
        const toVars = {};
        
        // Convert from animation to to animation
        Object.keys(fromVars).forEach(key => {
            if (key !== 'duration' && key !== 'ease' && key !== 'delay' && key !== 'stagger') {
                toVars[key] = getInitialValue(key);
                // Set initial state
                setInitialState(targets, key, fromVars[key]);
            }
        });

        return gsap.to(targets, Object.assign(toVars, {
            duration: fromVars.duration,
            ease: fromVars.ease,
            delay: fromVars.delay,
            stagger: fromVars.stagger
        }));
    };

    gsap.fromTo = function(targets, fromVars, toVars) {
        // Set initial state
        setInitialState(targets, fromVars);
        
        return gsap.to(targets, toVars);
    };

    gsap.timeline = function() {
        return new Timeline();
    };

    gsap.registerPlugin = function(plugin) {
        // Plugin registration stub
        if (plugin && plugin.name === 'ScrollTrigger') {
            gsap.ScrollTrigger = plugin;
        }
        return gsap;
    };

    // Utils object
    gsap.utils = {
        toArray: function(targets) {
            if (!targets) return [];
            if (typeof targets === 'string') {
                return Array.from(document.querySelectorAll(targets));
            }
            if (Array.isArray(targets)) return targets;
            return [targets];
        },
        interpolate: function(a, b, progress) {
            return a + (b - a) * progress;
        }
    };

    // ScrollTrigger plugin stub
    const ScrollTrigger = {
        name: 'ScrollTrigger',
        create: function(options) {
            const trigger = options.trigger;
            const onEnter = options.onEnter;
            const start = options.start || 'top 90%';
            
            if (!trigger || !onEnter) return;

            // Simple intersection observer implementation
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && onEnter) {
                        onEnter();
                        observer.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.1 });

            const element = typeof trigger === 'string' ? 
                document.querySelector(trigger) : trigger;
            
            if (element) {
                observer.observe(element);
            }
        }
    };

    // Helper functions
    function createAnimation(element, vars, duration) {
        const startTime = Date.now();
        const startValues = {};
        const endValues = {};

        // Get initial values
        Object.keys(vars).forEach(prop => {
            if (prop !== 'duration' && prop !== 'ease' && prop !== 'delay' && prop !== 'stagger' && prop !== 'scrollTrigger') {
                startValues[prop] = getCurrentValue(element, prop);
                endValues[prop] = vars[prop];
            }
        });

        return {
            play: function() {
                const animate = () => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const progress = Math.min(elapsed / duration, 1);
                    const easedProgress = applyEasing(progress, vars.ease);

                    // Apply values
                    Object.keys(endValues).forEach(prop => {
                        const currentValue = interpolate(startValues[prop], endValues[prop], easedProgress);
                        applyValue(element, prop, currentValue);
                    });

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                requestAnimationFrame(animate);
            }
        };
    }

    function getCurrentValue(element, prop) {
        switch(prop) {
            case 'x': return parseFloat(element.style.transform?.match(/translateX\(([-\d.]+)px\)/)?.[1] || 0);
            case 'y': return parseFloat(element.style.transform?.match(/translateY\(([-\d.]+)px\)/)?.[1] || 0);
            case 'scale': return parseFloat(element.style.transform?.match(/scale\(([\d.]+)\)/)?.[1] || 1);
            case 'rotation': return parseFloat(element.style.transform?.match(/rotate\(([-\d.]+)deg\)/)?.[1] || 0);
            case 'opacity': return parseFloat(getComputedStyle(element).opacity || 1);
            case 'yPercent': return 0;
            case 'textContent': return parseInt(element.textContent) || 0;
            default: return 0;
        }
    }

    function applyValue(element, prop, value) {
        switch(prop) {
            case 'x':
                updateTransform(element, 'translateX', `${value}px`);
                break;
            case 'y':
                updateTransform(element, 'translateY', `${value}px`);
                break;
            case 'scale':
                updateTransform(element, 'scale', value);
                break;
            case 'rotation':
                updateTransform(element, 'rotate', `${value}deg`);
                break;
            case 'opacity':
                element.style.opacity = value;
                break;
            case 'yPercent':
                updateTransform(element, 'translateY', `${value}%`);
                break;
            case 'textContent':
                element.textContent = Math.round(value);
                break;
        }
    }

    function updateTransform(element, prop, value) {
        const current = element.style.transform || '';
        const regex = new RegExp(`${prop}\\([^)]*\\)`, 'g');
        const newTransform = current.replace(regex, '') + ` ${prop}(${value})`;
        element.style.transform = newTransform.trim();
    }

    function interpolate(start, end, progress) {
        if (typeof start === 'number' && typeof end === 'number') {
            return start + (end - start) * progress;
        }
        return end;
    }

    function applyEasing(progress, ease = 'power2.out') {
        switch(ease) {
            case 'power2.out':
                return 1 - Math.pow(1 - progress, 2);
            case 'power3.out':
                return 1 - Math.pow(1 - progress, 3);
            case 'back.out(1.7)':
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(progress - 1, 3) + c1 * Math.pow(progress - 1, 2);
            case 'power2.inOut':
                return progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            case 'none':
                return progress;
            default:
                return progress;
        }
    }

    function getInitialValue(prop) {
        switch(prop) {
            case 'opacity': return 1;
            case 'scale': return 1;
            case 'x':
            case 'y':
            case 'rotation':
                return 0;
            default: return 0;
        }
    }

    function setInitialState(targets, fromVars) {
        const elements = gsap.utils.toArray(targets);
        
        elements.forEach(element => {
            if (typeof fromVars === 'object') {
                Object.keys(fromVars).forEach(prop => {
                    if (prop !== 'duration' && prop !== 'ease' && prop !== 'delay' && prop !== 'stagger') {
                        applyValue(element, prop, fromVars[prop]);
                    }
                });
            }
        });
    }

    // Export GSAP
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = gsap;
    } else if (typeof window !== 'undefined') {
        window.gsap = gsap;
        window.ScrollTrigger = ScrollTrigger;
    }

    // Export for ES6 modules
    exports.default = gsap;
    exports.gsap = gsap;
    exports.ScrollTrigger = ScrollTrigger;

    console.log('GSAP stub loaded successfully');
}));
