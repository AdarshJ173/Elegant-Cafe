/**
 * Three.js r158 - Minimal version for Cafe Showcase
 * This is a simplified version for demonstration purposes.
 * For production, use the official Three.js library from https://threejs.org/
 */

(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.THREE = {}));
}(this, function(exports) {
    'use strict';

    // Basic THREE.js stub implementation
    const THREE = {};

    // Math utilities
    THREE.MathUtils = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
    };

    // Vector3 class
    THREE.Vector3 = function(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    };
    
    THREE.Vector3.prototype = {
        set: function(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        },
        copy: function(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        multiplyScalar: function(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            return this;
        }
    };

    // Scene class
    THREE.Scene = function() {
        this.children = [];
        this.rotation = new THREE.Vector3();
    };
    
    THREE.Scene.prototype = {
        add: function(object) {
            this.children.push(object);
        },
        remove: function(object) {
            const index = this.children.indexOf(object);
            if (index !== -1) {
                this.children.splice(index, 1);
            }
        }
    };

    // Camera classes
    THREE.PerspectiveCamera = function(fov = 50, aspect = 1, near = 0.1, far = 2000) {
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
    };
    
    THREE.PerspectiveCamera.prototype = {
        lookAt: function(vector) {
            // Simplified look-at implementation
            this.target = vector;
        },
        updateProjectionMatrix: function() {
            // Simplified projection matrix update
        }
    };

    // WebGL Renderer
    THREE.WebGLRenderer = function(parameters = {}) {
        this.canvas = parameters.canvas || document.createElement('canvas');
        this.context = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
        this.shadowMap = {
            enabled: false,
            type: null
        };
        
        // Basic WebGL setup
        if (this.context) {
            this.context.clearColor(0.0, 0.0, 0.0, 0.0);
            this.context.enable(this.context.DEPTH_TEST);
        }
    };
    
    THREE.WebGLRenderer.prototype = {
        setSize: function(width, height) {
            this.canvas.width = width;
            this.canvas.height = height;
            if (this.context) {
                this.context.viewport(0, 0, width, height);
            }
        },
        render: function(scene, camera) {
            if (this.context) {
                this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
                // Simplified render - just clear the canvas
            }
        }
    };

    // Shadow map types
    THREE.PCFSoftShadowMap = 'PCFSoftShadowMap';

    // Geometry classes
    THREE.BufferGeometry = function() {
        this.attributes = {};
        this.type = 'BufferGeometry';
    };
    
    THREE.BufferGeometry.prototype = {
        setAttribute: function(name, attribute) {
            this.attributes[name] = attribute;
        },
        scale: function(x, y, z) {
            // Simplified scaling
            return this;
        }
    };

    THREE.CylinderGeometry = function(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8) {
        THREE.BufferGeometry.call(this);
        this.type = 'CylinderGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments
        };
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);

    THREE.SphereGeometry = function(radius = 1, widthSegments = 8, heightSegments = 6) {
        THREE.BufferGeometry.call(this);
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);

    THREE.BoxGeometry = function(width = 1, height = 1, depth = 1) {
        THREE.BufferGeometry.call(this);
        this.type = 'BoxGeometry';
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);

    THREE.PlaneGeometry = function(width = 1, height = 1) {
        THREE.BufferGeometry.call(this);
        this.type = 'PlaneGeometry';
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);

    THREE.TorusGeometry = function(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
        THREE.BufferGeometry.call(this);
        this.type = 'TorusGeometry';
    };
    THREE.TorusGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);

    // Buffer Attribute
    THREE.Float32BufferAttribute = function(array, itemSize) {
        this.array = array;
        this.itemSize = itemSize;
    };

    // Material classes
    THREE.MeshLambertMaterial = function(parameters = {}) {
        this.color = parameters.color || 0xffffff;
        this.transparent = parameters.transparent || false;
        this.opacity = parameters.opacity || 1.0;
    };

    THREE.PointsMaterial = function(parameters = {}) {
        this.color = parameters.color || 0xffffff;
        this.size = parameters.size || 1.0;
        this.transparent = parameters.transparent || false;
        this.opacity = parameters.opacity || 1.0;
    };

    // Mesh class
    THREE.Mesh = function(geometry, material) {
        this.geometry = geometry;
        this.material = material;
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.scale = new THREE.Vector3(1, 1, 1);
        this.castShadow = false;
        this.receiveShadow = false;
    };

    // Points class
    THREE.Points = function(geometry, material) {
        this.geometry = geometry;
        this.material = material;
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
    };

    // Group class
    THREE.Group = function() {
        this.children = [];
        this.position = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
    };
    
    THREE.Group.prototype = {
        add: function(object) {
            this.children.push(object);
        }
    };

    // Light classes
    THREE.AmbientLight = function(color = 0xffffff, intensity = 1) {
        this.color = color;
        this.intensity = intensity;
    };

    THREE.DirectionalLight = function(color = 0xffffff, intensity = 1) {
        this.color = color;
        this.intensity = intensity;
        this.position = new THREE.Vector3();
        this.castShadow = false;
    };

    // Export THREE object
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = THREE;
    } else if (typeof window !== 'undefined') {
        window.THREE = THREE;
    }
    
    // Also export for ES6 modules
    for (const key in THREE) {
        exports[key] = THREE[key];
    }

    exports.default = THREE;

    console.log('Three.js stub loaded successfully');
}));
